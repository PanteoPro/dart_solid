# SOLID принципы на dart
В данном репозитории, представлены примеры соблюдения принципов проектирования SOLID.

## Плюсы
- Легкость поддержки кода
- Масштабируемость
- Код легко читать
- Легкость переиспользования

## SRP - Single Responsibility Principle (Принцип единственной ответственности)
Определение: Класс должен содержать только те поля и методы, которые относятся к одной задаче (вопросу).

Через класс должна проходить только одна ось изменений.

### Пример как не надо:
```dart
class DateTemp {
    final double temp;
    final DateTime time;

    /// Логика вычисления времени
    void calculateTime() {}
    /// Логика вычисления температуры
    void calculateTemp() {}
}
```
Когда где-то в коде понадобится функционал вычисления `времени` из класса `DateTemp`, то придется:

- Делать копипаст в новый класс `DateTime` нужных свойств и методов (`плохо`)

Аналогично с функционалом вычисления `температуры`.

В итоге, будет 2 класса, которые частично выполняют тот же функционал из класса `DateTemp`.

Соответственно, при нахождении багов в классе `DateTemp`, фикс багов не будет попадать в новосозданные и не связанные классы.

### Пример как надо:
```dart
class DateTime {
    final DateTime time;

    void calculateTime() {}
}

class Temp {
    final double temp;

    void calculateTime() {}
}
```

Если нужен функционал из `обоих` классов, то новый класс может содержать оба объекта класса и делегирует им выполнение этих методов.

Самое частое нарушение этого принципа - `God object`

> Смотреть пример bin/SRP - Single Responsibility Principle/example.dart

## OCP - Open-Closed Principle (Принцип открытости/закрытости)

Определение: Классы, модули, функции, открыты для расширения, закрыты для изменения.

## Плюсы

- При добавлении новой функциональности, не изменяя предыдущую, не будет новый багов

## Как соблюдать OCP

Клиентский код должен зависеть от интерфейса, который неизменный.

## Пример

```dart
    abstract class Code {
        int method1();
        int method2();
    }

    /// Первая реализация интерфейса
    class CodeChild1 implements Code {
        @override
        int method1() {
            // Реализация
        }

        @override
        int method2() {
            // Реализация
        }
    }

    /// Реализация интерфейса с новыми функциями
    /// Может наследоваться от CodeChild1, либо частично делигировать функционал в CodeChild1
    /// class CodeChild2 extends CodeChild1
    class CodeChild2 implements Code {
        @override
        int method1() {
            // Реализация
            // Может делигировать выполнение предыдущей реализации CodeChild1.method1()
        }

        @override
        int method2() {
            // Реализация
            // Может делигировать выполнение предыдущей реализации CodeChild1.method2()
        }

        int method3(){
            // Новый функционал
        }
    }
```

Это делается для того, чтобы клиентский код был независем от реализаций интерфейса.

> Смотреть пример bin/OCP - Open-Closed Principle/example.dart